_COQPROJECT_NAME?=_CoqProject
UPDATE_COQPROJECT_TARGET?=update-_CoqProject
_COQPROJECT_EXCLUDED_VFILES?=

V = 0

SILENCE_COQC_0 = @echo "COQC $<"; #
SILENCE_COQC_1 =
SILENCE_COQC = $(SILENCE_COQC_$(V))

SILENCE_COQDEP_0 = @echo "COQDEP $<"; #
SILENCE_COQDEP_1 =
SILENCE_COQDEP = $(SILENCE_COQDEP_$(V))

SILENCE_OCAMLC_0 = @echo "OCAMLC $<"; #
SILENCE_OCAMLC_1 =
SILENCE_OCAMLC = $(SILENCE_OCAMLC_$(V))

SILENCE_OCAMLDEP_0 = @echo "OCAMLDEP $<"; #
SILENCE_OCAMLDEP_1 =
SILENCE_OCAMLDEP = $(SILENCE_OCAMLDEP_$(V))

SILENCE_OCAMLOPT_0 = @echo "OCAMLOPT $<"; #
SILENCE_OCAMLOPT_1 =
SILENCE_OCAMLOPT = $(SILENCE_OCAMLOPT_$(V))

Q_0 := @
Q_1 :=
Q = $(Q_$(V))

VECHO_0 := @echo
VECHO_1 := @true
VECHO = $(VECHO_$(V))

TIMED=
TIMECMD=
STDTIME?=/usr/bin/time -f "$* (user: %U mem: %M ko)"
TIMER=$(if $(TIMED), $(STDTIME), $(TIMECMD))

containing = $(foreach v,$2,$(if $(findstring $1,$v),$v))
not-containing = $(foreach v,$2,$(if $(findstring $1,$v),,$v))

.PHONY: clean FORCE $(UPDATE_COQPROJECT_TARGET)

FAST_TARGETS += archclean clean cleanall printenv clean-old $(UPDATE_COQPROJECT_TARGET) Makefile.coq
SUPER_FAST_TARGETS += $(UPDATE_COQPROJECT_TARGET) Makefile.coq

# pipe the output of coq_makefile through sed so that we don't have to run coqdep just to clean
# use tr to handle the fact that BSD sed doesn't substitute \n
Makefile.coq: Makefile _CoqProject
	$(VECHO) "COQ_MAKEFILE -f _CoqProject > $@"
	$(Q)$(COQBIN)coq_makefile COQC = "\$$(SILENCE_COQC)\$$(TIMER) \"\$$(COQBIN)coqc\"" COQDEP = "\$$(SILENCE_COQDEP)\"\$$(COQBIN)coqdep\" -c" -f _CoqProject | sed s'|^\(-include.*\)$$|ifneq ($$(filter-out $(FAST_TARGETS),$$(MAKECMDGOALS)),)~\1~else~ifeq ($$(MAKECMDGOALS),)~\1~endif~endif|g' | tr '~' '\n' | sed s'/^clean:$$/clean-old::/g' | sed s'/^clean::$$/clean-old::/g' | sed s'/^Makefile: /Makefile-old: /g' > $@

ifneq ($(filter-out $(SUPER_FAST_TARGETS),$(MAKECMDGOALS)),)
-include Makefile.coq
else
ifeq ($(MAKECMDGOALS),)
-include Makefile.coq
endif
endif

# overwrite OCAMLC, OCAMLOPT, OCAMLDEP to make `make` quieter
OCAMLC_OLD := $(OCAMLC)
OCAMLC = $(SILENCE_OCAMLC)$(OCAMLC_OLD)

OCAMLDEP_OLD := $(OCAMLDEP)
OCAMLDEP = $(SILENCE_OCAMLDEP)$(OCAMLDEP_OLD)

OCAMLOPT_OLD := $(OCAMLOPT)
OCAMLOPT = $(SILENCE_OCAMLOPT)$(OCAMLOPT_OLD)

clean::
	$(VECHO) "RM *.CMO *.CMI *.CMA"
	$(Q)rm -f $(ALLCMOFILES) $(CMIFILES) $(CMAFILES)
	$(VECHO) "RM *.CMX *.CMXS *.CMXA *.O *.A"
	$(Q)rm -f $(ALLCMOFILES:.cmo=.cmx) $(CMXAFILES) $(CMXSFILES) $(ALLCMOFILES:.cmo=.o) $(CMXAFILES:.cmxa=.a)
	$(VECHO) "RM *.ML.D *.MLI.D *.ML4.D *.MLLIB.D"
	$(Q)rm -f $(addsuffix .d,$(MLFILES) $(MLIFILES) $(ML4FILES) $(MLLIBFILES) $(MLPACKFILES))
	$(VECHO) "RM *.VO *.VI *.VIO *.G *.V.D *.V.BEAUTIFIED *.V.OLD"
	$(Q)rm -f $(VOFILES) $(VIFILES) $(VOFILES:.vo=.vio) $(GFILES) $(VFILES:.v=.v.d) $(VFILES:=.beautified) $(VFILES:=.old)
	$(VECHO) "RM *.PS *.PDF *.GLOB *.TEX *.G.TEX"
	$(Q)rm -f all.ps all-gal.ps all.pdf all-gal.pdf all.glob $(VFILES:.v=.glob) $(VFILES:.v=.tex) $(VFILES:.v=.g.tex) all-mli.tex
	$(VECHO) "FIND .coq-native -DELETE"
	$(Q)find . -name .coq-native -type d -empty -delete
	$(VECHO) "RM *.O *.NATIVE"
	$(Q)rm -f $(OBJFILES) $(OBJFILES:.o=.native) $(NATIVEFILES)
	- rm -rf html mlihtml uninstall_me.sh
	rm -f Makefile.coq

# Recursively find the transitively closed dependencies of the set $1
# of *.vo files, using an accumulating parameter $2 of dependencies
# previously found.  We extract the dependencies from the
# corresponding *.v.d files using sed(1), filter out previously found
# dependencies, sort to remove duplicates, then make a recursive call
# with the deduplicated newly found dependencies.  When $1 becomes
# empty, the result is $2.
read_deps = $(if $(wildcard $1),$(filter %.vo,$(shell sed -n 's/^[^:]*: // p' $(wildcard $1))))
vo_closure = $(if $1,$(call vo_closure,$(sort $(filter-out $1 $2,$(call read_deps,$(1:.vo=.v.d)))),$1 $2),$2)

vo_to_installv = $(addsuffix .v,$(basename $(call vo_closure,$(filter %.vo,$1))))

SORT_COQPROJECT = sed 's,[^/]*/,~&,g' | env LC_COLLATE=C sort | sed 's,~,,g'

$(VOFILES): FORCE

MISSING_COQPROJECT_VFILES = $(addsuffix .v,$(basename $(filter-out $(VOFILES),$(call vo_closure,$(VOFILES)))))
ifneq (,$(MISSING_COQPROJECT_VFILES))
FORCE::
	@ echo
	@ echo 'error: $(MISSING_COQPROJECT_VFILES) is missing from $(_COQPROJECT_NAME).'
	@ echo 'error: Please run `$(MAKE) $(UPDATE_COQPROJECT_TARGET)`.'
	@ echo
	@ false
endif

NONEXISTANT_COQPROJECT_VFILES = $(filter-out $(_COQPROJECT_EXCLUDED_VFILES) $(wildcard $(VFILES)),$(VFILES))
ifneq (,$(NONEXISTANT_COQPROJECT_VFILES))
FORCE::
	@ echo
	@ echo 'error: $(NONEXISTANT_COQPROJECT_VFILES) is in $(_COQPROJECT_NAME) but does not exist.'
	@ echo 'error: Please run `$(MAKE) $(UPDATE_COQPROJECT_TARGET)`.'
	@ echo
	@ false
endif
